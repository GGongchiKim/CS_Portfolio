<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>프로세스 & 스레드 학습 포트폴리오</title>

  <style>
    /* ===== 공통 스타일 (Data_Structure / Graphics / Network와 통일) ===== */
    :root {
      --bg: #0f1115;
      --panel: #151924;
      --card: #1b2030;
      --text: #e6ebff;
      --muted: #9ca3af;
      --subtext: #9ca3af;
      --accent: #7aa2ff;
      --accent-soft: rgba(122,162,255,0.14);
      --border: #252b3d;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
        "Apple SD Gothic Neo", "Malgun Gothic", "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #141826 0, #050610 55%, #000 100%);
      color: var(--text);
      line-height: 1.6;
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }

    /* ===== 상단 글로벌 헤더 (공통 탭) ===== */
    .global-header {
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(14px);
      background: linear-gradient(
        180deg,
        rgba(5,6,16,0.96),
        rgba(5,6,16,0.88),
        transparent
      );
      border-bottom: 1px solid rgba(30,64,175,0.6);
    }
    .global-header-inner {
      max-width: 1500px;
      margin: 0 auto;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .global-header-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--subtext);
    }
    .global-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .global-tab {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(15,23,42,0.95);
      font-size: 13px;
      color: var(--subtext);
      text-decoration: none;
      transition:
        background 0.15s ease,
        border-color 0.15s ease,
        color 0.15s ease,
        transform 0.05s ease;
    }
    .global-tab:hover {
      border-color: var(--accent);
      color: #e5e7eb;
      transform: translateY(-1px);
    }
    .global-tab.active {
      background: var(--accent);
      color: #020617;
      border-color: transparent;
    }
    @media (max-width: 720px) {
      .global-header-inner {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
    }

    /* ===== 페이지 2열 레이아웃 ===== */
    .page {
      max-width: 1500px;
      margin: 0 auto;
      padding: 24px 16px 40px;
      display: grid;
      grid-template-columns: 260px minmax(0, 1fr);
      gap: 24px;
    }

    /* ===== 사이드바 ===== */
    aside {
      position: sticky;
      top: 16px;
      align-self: flex-start;
    }

    .sidebar-card {
      background: linear-gradient(145deg, #181b24, #101320);
      border-radius: 18px;
      padding: 18px 16px 16px;
      border: 1px solid rgba(122,162,255,0.5);
      box-shadow: 0 18px 45px rgba(15,23,42,0.85);
    }

    .sidebar-title {
      font-size: 14px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: #9ca3ff;
      margin-bottom: 4px;
    }

    .sidebar-main {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .sidebar-sub {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 12px;
    }

    nav.toc {
      margin-top: 10px;
    }
    nav.toc ol {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 13px;
    }
    nav.toc li + li {
      margin-top: 4px;
    }
    nav.toc a {
      position: relative;
      display: block;
      padding-left: 14px;
      color: var(--muted);
    }
    nav.toc a::before {
      content: "•";
      position: absolute;
      left: 0;
      top: 0;
      color: var(--accent);
    }
    nav.toc a:hover {
      color: var(--accent);
    }

    /* ===== 메인 카드 ===== */
    main {
      background:
        radial-gradient(
          circle at top left,
          rgba(30,64,175,0.28),
          transparent 55%
        )
          fixed,
        linear-gradient(
          160deg,
          rgba(15,23,42,0.96),
          rgba(2,6,23,0.99)
        );
      border-radius: 24px;
      border: 1px solid rgba(39,45,70,0.9);
      box-shadow: 0 26px 65px rgba(15,23,42,0.95);
      padding: 22px 18px 26px;
    }

    section {
      margin-top: 22px;
      padding: 18px 18px 20px;
      border-radius: 16px;
      background: radial-gradient(
        circle at top left,
        rgba(50,80,180,0.15),
        rgba(10,12,22,0.9)
      );
      border: 1px solid var(--border);
    }

    h1,
    h2,
    h3 {
      margin: 0;
    }

    h2 {
      font-size: 22px;
      margin-bottom: 8px;
    }

    h3 {
      margin: 18px 0 12px;
      font-size: 18px;
    }

    p {
      margin: 6px 0 8px;
      line-height: 1.5;
      font-size: 14px;
    }

    ul {
      margin: 6px 0 10px 20px;
      padding: 0;
      font-size: 14px;
    }

    li {
      margin-bottom: 4px;
    }

    /* ===== 작은 라벨(Pill / Kicker) ===== */
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(8,10,22,0.9);
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .pill span {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--accent);
    }

    .kicker {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      text-transform: uppercase;
      color: var(--subtext);
      letter-spacing: 0.18em;
      margin-bottom: 6px;
    }
    .kicker::before {
      content: "";
      display: inline-block;
      width: 18px;
      height: 1px;
      background: linear-gradient(
        90deg,
        rgba(129,140,248,0.2),
        rgba(129,140,248,0.9)
      );
    }

    /* ===== Intro 타일 ===== */
    .tiles {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .tile {
      background: radial-gradient(
        circle at top left,
        rgba(79,70,229,0.35),
        rgba(10,12,24,0.96)
      );
      border-radius: 14px;
      padding: 10px 11px;
      border: 1px solid rgba(129,140,248,0.75);
    }
    .tile-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    .note {
      font-size: 12px;
      color: var(--subtext);
    }

    /* ===== 삽화 + 학습일지 블록 ===== */
    .block {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 2fr);
      gap: 16px;
      align-items: flex-start;
      margin-top: 10px;
    }
    .figure,
    .diary {
      background: rgba(10,12,24,0.94);
      border-radius: 16px;
      padding: 12px 13px;
      border: 1px solid var(--border);
    }
    .figure {
      box-shadow: inset 0 0 0 1px rgba(30,64,175,0.5);
    }
    .figure img {
      width: 100%;
      border-radius: 12px;
      display: block;
      margin: 4px 0 6px;
      background: #050611;
      border: 1px solid var(--border);
    }
    .caption {
      font-size: 12px;
      color: var(--muted);
    }

    .diary h4 {
      margin: 0 0 4px;
      font-size: 14px;
      color: var(--subtext);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .meta {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(129,140,248,0.7);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #c7d2fe;
    }
    .diary ul {
      border-left: 2px solid rgba(129,140,248,0.4);
      padding-left: 10px;
    }
    .diary p.note {
      border-radius: 10px;
      border: 1px dashed rgba(129,140,248,0.5);
      padding: 7px 9px;
      background: rgba(8,10,24,0.95);
      font-size: 12px;
    }

    /* ===== 푸터 ===== */
    .footer {
      margin-top: 24px;
      text-align: right;
      font-size: 11px;
      color: var(--muted);
      border-top: 1px solid rgba(31,41,55,0.9);
      padding-top: 14px;
    }

    @media (max-width: 960px) {
      .page {
        grid-template-columns: 1fr;
      }
      aside {
        position: static;
        order: -1;
      }
      main {
        padding: 18px 14px 22px;
      }
      .block {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- 글로벌 탭 헤더 -->
  <header class="global-header">
    <div class="global-header-inner">
      <div class="global-header-title">CS Portfolio · Process & Thread</div>
      <nav class="global-tabs" aria-label="CS Portfolio Tabs">
        <!-- 경로는 실제 폴더 구조에 맞게 조정 -->
        <a class="global-tab" href="../index.html">Index</a>
        <a class="global-tab" href="../1_Data_Structure/Data_Structure.html">자료구조</a>
        <a class="global-tab active" href="./process.html">프로세스</a>
        <a class="global-tab" href="../3_Graphics/Graphics.html">그래픽스</a>
        <a class="global-tab" href="../4_Network/Network.html">네트워크</a>
      </nav>
    </div>
  </header>

  <div class="page" role="document">
    <!-- 사이드 목차 -->
    <aside>
      <div class="sidebar-card">
        <div class="sidebar-title">CS Portfolio</div>
        <div class="sidebar-main">프로세스 · 스레드 실행 흐름</div>
        <div class="sidebar-sub">
          공사장 비유와 삽화를 통해
          <b>프로그램 로딩 → 프로세스/스레드 → 동시성 → 스케줄러 → 컨텍스트 스위칭</b> 흐름을
          한눈에 정리한 운영체제 학습 기록이다.
        </div>

        <nav class="toc" aria-label="문서 목차">
          <ol>
            <li><a href="#intro">Intro</a></li>
            <li><a href="#load">1. 프로그램 로딩 &amp; 메모리 구조</a></li>
            <li><a href="#proc-thread">2. 프로세스와 스레드, 공유 메모리</a></li>
            <li><a href="#concurrency">3. 동시성 문제: 레이스 &amp; 데드락</a></li>
            <li><a href="#scheduler">4. 스케줄러와 작업 배정</a></li>
            <li><a href="#context">5. 컨텍스트 스위칭</a></li>
          </ol>
        </nav>
      </div>
    </aside>

    <!-- 메인 콘텐츠 -->
    <main>
      <!-- 헤더 -->
      <section id="intro">
        <div class="pill"><span></span>Intro</div>
        <h2>프로세스 &amp; 스레드 – 운영체제 위에서 게임이 돌아가는 방식</h2>
        <p class="note">
          교과서 개념을 그대로 옮기기보다는, 하나의 공사장 비유와 삽화를 통해
          “게임 엔진이 운영체제 위에서 어떻게 실행되는지”를 이해하고 정리한 학습 포트폴리오다.
        </p>
        <p>
          게임 클라이언트 프로그래머에게 운영체제의 프로세스와 스레드 구조는 단순한 이론이 아니다.
          프레임 유지, 입력 처리 타이밍, 렌더링 파이프라인, 비동기 작업은 모두 OS 위에서 돌아가는
          <b>프로세스와 스레드, 스케줄링 구조</b>에 영향을 받는다.
        </p>
        <p>
          이 문서는 교과서의 정의를 외우는 대신, 하나의 <b>건설 현장 비유</b>를 사용해
          프로그램이 실행되는 전체 흐름(프로그램 로딩 → 프로세스/스레드 구조 → 동시성 → 스케줄러 → 컨텍스트 스위칭)을
          그림과 함께 정리한 학습 기록이다.
          “실제로 게임 엔진이 OS 위에서 어떻게 돌아가는가?”를 이해하는 것을 목표로 했다.
        </p>
        <p>전체 구성은 다음 다섯 단계로 이루어져 있다.</p>
        <div class="tiles">
          <div class="tile">
            <div class="tile-title">1. 프로그램 로딩 &amp; 메모리</div>
            <div class="note">
              디스크의 실행 파일이 CODE / DATA / STACK 구역을 가진
              프로세스 주소 공간으로 펼쳐지는 과정.
            </div>
          </div>
          <div class="tile">
            <div class="tile-title">2. 프로세스 &amp; 스레드</div>
            <div class="note">
              하나의 현장(프로세스) 안에서 여러 작업조(스레드)가
              같은 자원을 공유하며 일하는 구조.
            </div>
          </div>
          <div class="tile">
            <div class="tile-title">3. 동시성 문제</div>
            <div class="note">
              여러 작업조가 동시에 같은 자재를 만질 때 생기는
              레이스컨디션과 서로 기다리다가 멈추는 데드락.
            </div>
          </div>
          <div class="tile">
            <div class="tile-title">4. 스케줄러</div>
            <div class="note">
              작업을 언제 어떤 순서로 시킬지 결정해서
              CPU 시간을 나눠주는 현장 감독.
            </div>
          </div>
          <div class="tile">
            <div class="tile-title">5. 컨텍스트 스위칭</div>
            <div class="note">
              OS 신호에 맞춰 작업대를 바꾸고,
              이전 작업 상태를 저장·복원하는 실제 전환 과정.
            </div>
          </div>
        </div>
      </section>

      <!-- 1. 프로그램 로딩 & 메모리 구조 -->
      <section id="load">
        <div class="pill"><span></span>1. 준비</div>
        <h3>프로그램 로딩 &amp; 메모리 구조 – 설계도를 현장으로 가져오기</h3>
        <div class="block">
          <div class="figure">
            <h4>삽화</h4>
            <img src="img/process_001.png"
                 alt="OS가 PROGRAM 설계도를 CPU에게 전달하고, CODE/DATA/STACK 현장이 펼쳐진 삽화">
            <div class="caption">
              OS가 <b>PROGRAM</b> 서류를 받아 CODE / DATA / STACK 구역이 있는 건설 현장을 여는 모습.
              실행 파일이 메모리 속 “프로세스 주소 공간”으로 펼쳐진다.
            </div>
          </div>
          <div class="diary">
            <h4>학습일지</h4>
            <div class="meta">
              <span class="badge">키워드</span>
              로더, 코드/데이터/스택, 주소 공간, 엔트리포인트
            </div>
            <p>
              디스크에 있을 때 실행 파일은 그저 <b>종이 설계도</b>에 가깝다.
              사용자가 프로그램을 실행하면 OS의 <b>로더(Loader)</b>가 동작해서
              이 설계도를 읽고, 메모리 위에 <b>코드, 데이터, 스택(그리고 힙)</b> 구역을 가진
              하나의 <b>주소 공간</b>으로 펼친다.
            </p>
            <p>
              이 주소 공간이 곧 하나의 <b>공사 현장(프로세스)</b>이다.
              CODE 영역에는 “어떤 자재를 어떻게 가공하고 조립해 공사를 진행할지”를 적어 둔
              <b>시공법(함수) 설계서</b>가 모여 있고,
              DATA 영역은 공사에 쓸 <b>자재를 쌓아 둔 자재 창고</b>,
              STACK 영역은 현재 진행 중인 공정에 필요한 <b>시공법 페이지와 특수 자재/도구를
              임시로 올려 두는 선반</b>처럼 볼 수 있다.
            </p>
            <p>
              로더는 필요한 라이브러리를 연결하고 초기화 코드를 실행한 뒤,
              마지막에 <b>엔트리 포인트</b>(main 등)로 점프한다.
              이 시점부터 CPU 입장에서는 “이 현장에서 어떤 일을 할지”만
              처리하면 된다.
            </p>
            <ul>
              <li>디스크의 실행 파일 → 메모리 속 <b>프로세스 주소 공간</b>으로 변환</li>
              <li>CODE 영역: 기계어 명령, DATA 영역: 전역/정적 데이터</li>
              <li>STACK: 함수 호출·지역 변수를 위한 작업 공간</li>
            </ul>
            <p class="note">
              “컴파일”은 설계도를 만드는 과정이고, “로딩”은 그 설계도로
              실제 공사 현장을 여는 과정이라는 비유가 가장 이해가 잘 됐다.
            </p>
          </div>
        </div>
      </section>

      <!-- 2. 프로세스 & 스레드 -->
      <section id="proc-thread">
        <div class="pill"><span></span>2. 실행 단위</div>
        <h3>프로세스와 스레드 – 하나의 현장과 여러 작업조</h3>
        <div class="block">
          <div class="figure">
            <h4>삽화</h4>
            <img src="img/process_002.png"
                 alt="공사 현장(프로세스) 안에서 여러 작업조(스레드)가 같은 창고를 공유하는 모습">
            <div class="caption">
              하나의 공사 현장(프로세스) 안에서 여러 작업조(스레드)가
              같은 자재 창고(DATA)와 도면(CODE)을 공유하며 일하는 구조.
            </div>
          </div>
          <div class="diary">
            <h4>학습일지</h4>
            <div class="meta">
              <span class="badge">키워드</span>
              프로세스, 스레드, 주소 공간 공유
            </div>
            <p>
              프로세스는 OS 입장에서 <b>하나의 큰 실행 단위</b>다.
              각 프로세스는 자신만의 CODE / DATA / STACK / HEAP이 있는
              독립적인 주소 공간을 가지고, 보통 프로그램 하나당 프로세스 하나가 생성된다.
            </p>
            <p class="note">
              엄밀히 말하면 우리가 쓰는 <b>윈도우나 안드로이드 운영체제 자체도 결국 하나의 거대한 프로세스 집합</b> 위에 돌아간다.
              사용자가 게임을 실행하면 OS는 그 위에 <b>새로운 프로세스를 “하나의 공사 현장”처럼 올리는 것</b>에 가깝고,
              각 현장은 서로의 자재 창고와 도면을 직접 들여다볼 수 없다
              (필요하면 OS가 제공하는 API를 통해서만 간접적으로 소통한다).
            </p>
            <p>
              한편 스레드는 이 프로세스 내부에서 움직이는 <b>“작업조”</b>다.
              스레드는 서로 같은 CODE / DATA / HEAP을 공유하되, <b>자신만의 스택</b>을 가진다.
              같은 현장 안에서 여러 작업조가 동시에 일하면서도,
              각 작업조가 들고 있는 작업 순서와 임시 도구(지역 변수)는 따로 관리되는 셈이다.
            </p>
            <ul>
              <li>프로세스: OS가 관리하는 <b>독립적인 공사 현장</b></li>
              <li>스레드: 같은 현장 안에서 돌아가는 여러 <b>작업조</b></li>
              <li>공유: CODE / DATA / HEAP, 개별 스택은 스레드마다 따로</li>
            </ul>
            <p class="note">
              처음에는 “프로세스 vs 스레드”를 그냥 추상적인 실행 단위로만 외우고 있었는데,
              “하나의 현장 안에서 작업조들이 창고를 같이 쓰는 구조”라고 이해하니
              동시성 문제(레이스컨디션, 데드락 등)가 왜 생기는지 훨씬 잘 보이기 시작했다.
            </p>
          </div>
        </div>
      </section>

      <!-- 3. 동시성 문제 -->
      <section id="concurrency">
        <div class="pill"><span></span>3. 동시성</div>
        <h3>레이스컨디션 &amp; 데드락 – 같은 자재를 동시에 만질 때 생기는 문제</h3>
        <div class="block">
          <div class="figure">
            <h4>삽화</h4>
            <img src="img/process_003.png"
                 alt="여러 작업조가 같은 자재에 동시에 손을 대며 엉키는 모습">
            <div class="caption">
              여러 스레드가 같은 자재(공유 데이터)를 동시에 만지다가
              서로의 작업이 꼬이고 멈춰버리는 상황을 공사 현장 비유로 표현.
            </div>
          </div>
          <div class="diary">
            <h4>학습일지</h4>
            <div class="meta">
              <span class="badge">키워드</span>
              레이스컨디션, 데드락, 뮤텍스, 임계구역
            </div>
            <p>
              스레드가 같은 DATA(자재 창고)를 공유한다는 것은,
              여러 작업조가 동시에 같은 자재 더미를 만질 수 있다는 뜻이다.
              이때 <b>누가 먼저, 어떤 순서로 자재를 가져갔는지</b>에 따라
              결과가 달라질 수 있다. 이게 바로 <b>레이스컨디션</b>이다.
            </p>
            <p>
              또 서로 자재를 하나씩 쥔 채, 상대가 들고 있는 자재를 기다리기만 한다면
              공사가 영원히 진행되지 않는 <b>데드락</b>이 발생한다.
              실제 코드에서는 락을 거는 순서가 뒤섞일 때 이런 상황이 만들어진다.
            </p>
            <ul>
              <li>레이스컨디션: 실행 순서에 따라 결과가 달라지는 상황</li>
              <li>데드락: 서로 상대의 자원을 기다리느라 영원히 멈추는 상황</li>
              <li>해결책: 임계구역 설정, 락 순서 정하기, 타임아웃 등</li>
            </ul>
            <p class="note">
              게임 코드에서 “가끔 한 번씩 튀는 버그”가 왜 발생하는지,
              그리고 멀티스레드 환경에서 재현이 어려운 버그가 왜 무섭다고 하는지
              공사 현장 비유를 통해 직관적으로 이해할 수 있었다.
            </p>
          </div>
        </div>
      </section>

      <!-- 4. 스케줄러 -->
      <section id="scheduler">
        <div class="pill"><span></span>4. 배치</div>
        <h3>스케줄러 – CPU 시간을 어떻게 나눠 쓸 것인가</h3>
        <div class="block">
          <div class="figure">
            <h4>삽화</h4>
            <img src="img/process_004.png"
                 alt="스케줄러가 여러 작업조를 CPU 작업대로 보내는 모습">
            <div class="caption">
              CPU 작업대 앞에서 스케줄러가 여러 스레드를 번갈아가며 올려 보내는 구조.
              각 코어마다 하나씩 작업대를 가지고, 짧은 시간 단위로 번갈아 작업한다.
            </div>
          </div>
          <div class="diary">
            <h4>학습일지</h4>
            <div class="meta">
              <span class="badge">키워드</span>
              타임슬라이스, 우선순위, 코어, 스케줄링 정책
            </div>
            <p>
              실제 하드웨어 레벨에서 CPU 코어 하나는 <b>한 순간에는 하나의 스레드만</b> 실행한다.
              (하이퍼스레딩 등으로 한 코어가 여러 스레드를 번갈아 처리할 수 있지만,
              결국 <b>한 클럭 사이클에는 하나의 명령</b>만 실행된다는 점은 같다.)
            </p>
            <p>
              그런데 우리 눈에는 여러 프로그램이 동시에 실행되는 것처럼 보인다.
              이는 OS의 <b>스케줄러</b>가 아주 짧은 타임슬라이스 단위로
              “이번에는 이 스레드, 다음에는 저 스레드”를 번갈아 CPU에 올리기 때문이다.
              여러 코어가 있다면 각 코어에 동시에 다른 스레드를 올릴 수도 있다.
            </p>
            <ul>
              <li>단일 코어: 한 순간에는 한 스레드만 실행</li>
              <li>멀티 코어: 코어 수만큼 여러 스레드가 병렬 실행</li>
              <li>스케줄러: 어떤 스레드에 얼마나 자주, 얼마나 길게 CPU를 줄지 결정</li>
            </ul>
            <p class="note">
              게임 루프, 렌더링 스레드, 자원 로딩 스레드 등이 스케줄링 정책에 따라
              CPU 시간을 나눠 쓰기 때문에, 프레임 드랍이나 입력 지연 문제를 볼 때도
              “이 스레드들이 CPU를 어떻게 쓰고 있나?”라는 관점으로 바라볼 수 있게 되었다.
            </p>
          </div>
        </div>
      </section>

      <!-- 5. 컨텍스트 스위칭 -->
      <section id="context">
        <div class="pill"><span></span>5. 전환</div>
        <h3>컨텍스트 스위칭 – 작업대를 바꾸면서 상태를 저장·복원하기</h3>
        <div class="block">
          <div class="figure">
            <h4>삽화</h4>
            <img src="img/process_005.png"
                 alt="한 작업자가 OS 신호에 따라 작업대를 바꾸며 상태를 선반에 저장하는 모습">
            <div class="caption">
              OS가 신호를 보내면 작업자는 현재 작업 상태를 선반에 올려두고,
              다른 작업대로 이동해 새로운 작업을 시작한다.
              이것이 컨텍스트 스위칭에 해당한다.
            </div>
          </div>
          <div class="diary">
            <h4>학습일지</h4>
            <div class="meta">
              <span class="badge">키워드</span>
              컨텍스트, 레지스터, 스택 포인터, 스위칭 비용
            </div>
            <p>
              컨텍스트 스위칭은 말 그대로 CPU가 실행 중인 스레드를 바꾸는 과정이다.
              이때 OS는 현재 스레드의 <b>레지스터 값, 프로그램 카운터, 스택 포인터</b> 등
              실행 상태를 저장하고, 다음에 실행할 스레드의 상태를 다시 레지스터에 복원한다.
            </p>
            <p>
              공사 현장 비유로 보면, 작업자가 현재 작업대를 떠나기 전에
              “어디까지 했는지, 지금 어떤 도구를 들고 있는지”를 선반에 정리해 두고,
              다른 작업대로 이동해 그 작업의 상태를 다시 꺼내 오는 과정에 가깝다.
            </p>
            <ul>
              <li>컨텍스트: 스레드가 어디까지 무엇을 하고 있었는지에 대한 상태 정보</li>
              <li>스위칭: 이전 컨텍스트 저장 → 새 컨텍스트 복원</li>
              <li>비용: 스위칭이 잦을수록 오버헤드 증가</li>
            </ul>
            <p class="note">
              컨텍스트 스위칭의 비용을 이해하고 나니, “스레드를 많이 쓰면 무조건 좋은가?”에 대한
              고민을 하게 되었다. 게임 클라이언트에서는 “실제로 병렬화가 필요한 작업”만
              스레드로 분리하고, 나머지는 메인 스레드에서 일괄 처리하는 구조가 왜 많이 쓰이는지도
              함께 이해할 수 있었다.
            </p>
          </div>
        </div>
      </section>

<section id="summary"> 
  <h2>성과</h2>
  <!-- 성과 카드 -->
  <div class="card insight" style="margin-top: 12px;">
    <p>
      이번 운영체제(Process · Thread) 파트를 학습하며,
      게임 클라이언트 프로그래머에게 프로세스 구조와 스레드 실행 방식이
      단순 이론을 넘어 <strong>프레임 유지, 입력 처리 타이밍, 비동기 로딩, 렌더링 구조</strong> 등
      실질적인 개발 전반에 직결된다는 점을 명확히 이해하게 되었습니다.
    </p>
    <p>
      특히 공사장 비유를 기반으로 전체 실행 흐름을 재정리하면서,
      프로그램 로딩 → 프로세스 주소 공간 → 스레드 공유 메모리 →
      동시성 문제 → 스케줄러 → 컨텍스트 스위칭까지의 구조가
      서로 어떤 방식으로 연결되어 실제 게임 실행에 영향을 주는지
      <strong>하나의 일관된 흐름으로 설명할 수 있게 된 점</strong>이 가장 큰 성과였습니다.
    </p>
    <p>
      이제는 OS가 CPU 시간을 어떻게 배분하고, 어떤 상황에서 병렬 처리가 필요하며,
      언제 스레드가 오히려 병목을 만들 수 있는지 판단할 수 있게 되었고,
      이러한 이해를 통해 <strong>더 안정적인 게임 코드 구조</strong>를 설계할 수 있는 기반을 갖추게 되었습니다.
    </p>
  </div>
</section>


      <div class="footer">
        정리 기준: 2025년 운영체제(프로세스 · 스레드) 학습 내용 기반
      </div>
    </main>
  </div>
</body>
</html>
